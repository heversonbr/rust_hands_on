= Declarative Macros
//  chatgpt

Macros help you avoid repetition. In many situations, you might need similar functionality across different parts of your code, but with varying types. Using a macro allows you to generate that code dynamically, reducing redundancy and making your code more efficient.

Declarative macros, often referred to as macro_rules!, are a powerful mechanism for metaprogramming 
that allows you to write code that writes other code. 
They work based on pattern matching, 
where you define patterns for input and specify how those patterns should expand into code.

== Key Features

- Pattern Matching: Macros match specific patterns of tokens (like variables, types, or expressions) and replace them with code according to the macro's rules.
- Code Expansion: When invoked, the macro expands into the corresponding Rust code, effectively generating new code at compile-time.
- Reusable: They reduce code repetition by allowing you to write generic templates that can apply to different inputs.

=== Basic examples

[source, rust]
----
macro_rules! say_hello {
    () => {
        println!("Hello, World!");
    };
}

fn main() {
    say_hello!();  // after compiling it expands to: println!("Hello, World!");
}
----

In this simple example:

- say_hello!() matches the empty pattern () which is passed as an argument (empty arguments).
- and then, at compile time this code expands to the code `println!("Hello, World!");`.

We can also write macros that accept arguments to generate more complex code, for instance:

[source, rust]
----
macro_rules! create_function {
    ($name:ident) => {
        fn $name() {
            println!("You called {:?}()", stringify!($name));
        }
    };
}

create_function!(foo);  
// at compile time generates: fn foo() { println!("You called foo()"); }

fn main() {
    foo();  // Prints: You called foo()
}
----

Here, `$name:ident` matches an identifier (`foo`), and `stringify!` turns it into a string for the `println!`. We explain more about the matcher `$name:ident` later.

== Creating declarative macros

=== Basic structure

[source, rust]
---- 
macro_rules! <macro_name> {
    // here start the body of the macro with rules
    $rule0 ;
    $rule1 ;
    â€¦
    $ruleN ;
}
----

There must be at least one rule and each rule looks like the following: 

----
($matcher) => {$expansion}
----

The left side is the matcher _pattern_, and the _expansion_ part of a rule (the right side) which is also called its _transcriber_.

NOTE: When a macro is invoked, the macro_rules! interpreter goes through the rules one by one, in declaration order. For each rule, it tries to match the contents of the input token tree against the rule's matcher. If the input matches the matcher, the invocation is replaced by the expansion. If all rules fail to match, the expansion fails with an error.


=== Going step-by-step

- We start the macro definition with `macro_rules!` keyword followed by the macro's name.

[source, rust]
---- 
macro_rules! my_macro {
    // macro's body goes here
}
----

Here `my_macro` is the name of our macro. 

- Next, we define the _patterns_ and their _expansions_ in the macro's body. The body is similar to the structure of a match expression. 

Macros match patterns that you define, and they expand into Rust code based on those _patterns_. A _pattern_ consists of tokens like literals, identifiers, or more complex structures (like expressions). The _expansion_ is the code that replaces the macro invocation when it matches the pattern.

[source, rust]
----
macro_rules! my_macro {
    // Pattern    =>  Transcriber (expansion)
    ($name:ident) => { println!("Hello, {}", stringify!($name)); };
}
----

In the example above, the macro tries to match input with the matcher pattern, here described as an identifier (`$name`). When matched, it expands it into a `println!` statement with the name as a string. 
//Matchers can also contain captures as we discuss later.

- Invoke the Macro

Once the macro is defined, you can invoke the macro in your code using the syntax `my_macro!(argument)`. 

[source, rust]
----
my_macro!(world);     // this will expand to println!("Hello, world");
----

- Multiple Patterns

Macros can support multiple patterns, allowing you to handle different input forms, for instance:

[source, rust]
----
macro_rules! my_macro {
    () => {
        println!("No argument provided!");
    };
    ($name:ident) => {
        println!("Hello, {}", stringify!($name));
    };
}
----
In this example, the macro has two rules with different patterns to match. It expends in two ways. It can either print a default message with no argument or print a greeting if an identifier is passed as an argument. 

[source, rust]
----
my_macro!();      // Expands to: println!("No argument provided!");
my_macro!(world); // Expands to: println!("Hello, world");
----

- Multiple arguments

We can also pass multiple arguments to a single rule. For instance, consider a scenario where you need to define functions that operate on different types. Without macros, you would write the same logic repeatedly for each desired type. 
By using macros we can pass the name of the function and the type we want to implement as arguments and then we invoke the macro for each type we want to create.

[source, rust]
----
macro_rules! create_function {
    ($name:ident, $t:ty) => {
        fn $name(val: $t) {
            println!("Value is: {}", val);
        }
    };
}

create_function!(print_int, i32);   
// Expands to (creates a function for i32):
//    fn print_int(val: i32) {
//            println!("Value is: {}", val);
//    }

create_function!(print_float, f64); 
// Expands to (creates a function for f64):
//    fn print_float(val: f64) {
//            println!("Value is: {}", val);
//    }
----

In the example above, the macro generates two functions, one for i32 and another for f64, with a single macro definition, avoiding code repetition. The first argument ($name) defines the function name, while the second argument ($t) specifies the type we want to pass as an argument to our function.


- Repetitions in Macros

Macros also support repetition for both the `matcher` and the `transcriber` (expansion) by using the  syntax:

- `$( ... ),*` , or
- `$( ... )*`

This allows you to match a variable number of inputs elements such as an array `[1,2,3,4,5]` and apply a single expantion to each of the input elements.

[source, rust]
----
macro_rules! repeat_macro {
    
    ($($e:expr),*) => {  // $($e:expr),*  -> matches a comma-separated list of expressions    
        $( println!("Value: {}", $e); )*  // $(...)*` -> repetition for applying the expansion to each input matching 
    };
}

repeat_macro!(1, 2, 3, 4, 5);
----

This expands into multiple println! calls:

[source, rust]
----
println!("Value: 1");
println!("Value: 2");
println!("Value: 3");
println!("Value: 4");
println!("Value: 5");
----

- Repetitions of multiple argument

A macro can take two arguments and allows those pairs of arguments to be repeated multiple times. Here's an example that demonstrates how to achieve this using macro repetitions (`$()*`):

[source, rust]
----
macro_rules! create_functions {
    // Match repeated pairs of arguments
    ($( $name:ident, $t:ty );* ) => {
        $(
            fn $name(val: $t) {
                println!("Function {} called with value: {}", stringify!($name), val);
            }
        )*
    };
}

// Using the macro to create multiple functions
create_functions!(
    print_int, i32;
    print_float, f64;
    print_str, &str
);

fn main() {
    print_int(10);  
    // prints "Function print_int called with value: 10"
    print_float(3.14);  
    // prints "Function print_float called with value: 3.14" 
    print_str("Hello");  
    // prints "Function print_str called with value: Hello"
}

----

Note that, the macro matches repeated pairs of arguments using `$( ... );*`.

- `$( ... )*` allows us to repeat a pattern multiple times
- the `;` separates each pair of arguments
- `$name:ident` matches the function name, and 
- `$t:ty` matches the type

Inside the macro body, the pattern is expanded for each provided pair of arguments.


- Repetitions with arguments as tuples

We can also define a macro that takes a series of tuples as input and processes them.
For example, lets assume we want to create a macro that generates multiple functions by passing pairs of values (function name and type) as tuples. This allows us to reduce redundancy and make our code more flexible.

[source, rust]
----
macro_rules! create_functions {
     // Match repeated tuples
    ($(($name:ident, $t:ty)),* ) => {
        $(
            fn $name(val: $t) {
                println!("Function {} called with value: {}", stringify!($name), val);
            }
        )*
    };
}
// Using the macro with tuples as arguments
create_functions!(
    (print_int, i32),
    (print_float, f64),
    (print_str, &str)
);

fn main() {
    print_int(10);
    print_float(3.14);
    print_str("Hello");
}
----
The macro matches repeated tuples using `$( ... ),*`.

- `($name:ident, $t:ty)` is the matcher pattern that will be repeated, which is verified against each tuple. 
- each tuple contains two elements: `$name:ident` for the function name and` $t:ty` for the type
- `$name:ident` means we are expecting an identifier (a function name in this case).
-- `$t:ty` means we are expecting a type.

- `$( ... )*` allows you to repeat a pattern
- the `,` between the `*` means that the tuples should be separated by commas
- => : This separates the pattern on the left from the macro's body (the code it will expand into).

The body of the macro expands for each tuple, generating a function for each pair.
Inside the macro's body, we use `$()*` to repeat the block of code for each tuple.

- A function is defined with the name provided by $name.
- The argument val is of the type provided by $t.
- stringify!($name) converts the function name into a string so we can print it.- 

==== Fragment specifiers

Captures are written as a dollar ($) followed by an identifier, a colon (:), and finally the kind of capture which is also called the _fragment-specifier_. We use _fragment specifiers_ to determine the type of input that a macro will match. They are written after the $ and define what kind of token a pattern can capture.

Hereâ€™s a list of the most common fragment specifiers:

|===
| Fragment | Description | Example 

| `ident` | Matches an identifier (like a variable or function name, this includes keywords) | `$name:ident` matches `foo`
| `expr` | Matches any valid Rust expression |   `$e:expr` matches `3 + 5`
| ty | Matches a type |   `$t:ty` matches `i32`
| `stmt` | Matches a single statement | `$s:stmt` matches `let x = 5;`  
| `block` | Matches a block of code (enclosed in `{}`) | `$b:block` matches `{ x + 1 }`
| `path` | Matches a path (e.g., a module or type path) | `$p:path` matches `std::io::Read`
| `meta` | Matches meta items, often used for attributes |  `$m:meta` matches `#[derive(Debug)]` 
| `tt` | Matches any single token tree (a sequence of tokens) |  `$t:tt` matches any token 
| `literal` | Matches a literal value (like a number or string) |  `$l:literal` matches `42`
| item | matches any of Rust's item definitions | function, struct, module, impl, etc.
| pat | Matches any kind of pattern | `$p:pat` matches `Some(x)`, `"literal"`, `0..5`
| meta | matches the contents of an attribute | things that go inside the #[...] and #![...] 
| lifetime |  matches a lifetime or label |  e.g., `'foo`, `'static`, ...
| vis | Matches a possible empty visibility modifier | e.g.,`pub`, `pub(crate)`)
|===

- Examples with fragment specifiers

[source, rust]
----
macro_rules! example_macro {
    // Match an identifier (like a variable or function name)
    ($name:ident) => {
        println!("Identifier: {}", stringify!($name));
    };
    // Match an expression
    ($e:expr) => {
        println!("Expression result: {}", $e);
    };
    // Match a type
    ($t:ty) => {
        println!("Type: {}", stringify!($t));
    };
}
----

And then, we can invoke the macro with different types of input.

[source, rust]
----
example_macro!(my_var);    // Matches identifier
example_macro!(5 + 3);     // Matches expression
example_macro!(i32);       // Matches type
----


== Take away


- Use macros for reducing boilerplate: Macros are ideal for situations where you need to reduce repetitive code.
- Keep macros simple: Overly complex macros can make code harder to understand and debug.
- Use procedural macros for complex logic: If declarative macros become too complicated, consider using a procedural macro for more advanced code generation.

Creating declarative macros in Rust involves defining patterns with macro_rules! and using fragment specifiers to capture different types of tokens (identifiers, expressions, types, etc.). Declarative macros are highly flexible and allow for code generation that reduces boilerplate and repetition. However, they should be used thoughtfully to maintain code clarity.