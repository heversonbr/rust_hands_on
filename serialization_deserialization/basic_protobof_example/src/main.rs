
mod person {

    //This line tells Rust to include the Rust code that was generated from a .proto file by prost_build at compile time.
	//•	env!("OUT_DIR") → This fetches the path to the build output directory where cargo stores generated files, 
    //                    typically target/debug/build/<crate-name>/out/
	//•	concat!(env!("OUT_DIR"), "/person.rs") → This creates a full path to the generated file, in this case '/person.rs'
	//•	include!(...) → This inserts the contents of 'person.rs' into the current Rust module.
    include!(concat!(env!("OUT_DIR"), "/person.rs"));

    // as a result of the 'build', the file person.rs is created by 'prost-build' with the following content:
    //
    // This file is @generated by prost-build.
    // #[allow(clippy::derive_partial_eq_without_eq)]
    // #[derive(Clone, PartialEq, ::prost::Message)]
    // pub struct Person {
    //     #[prost(string, tag = "1")]
    //     pub name: ::prost::alloc::string::String,
    //     #[prost(int32, tag = "2")]
    //     pub age: i32,
    //     #[prost(string, repeated, tag = "3")]
    //     pub emails: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    // }
}

use person::Person;     // include the struct Person from the module 'person' in the main.rs 
use prost::Message;

fn main() {
    // Create a new Person instance
    let person = Person {
        name: "Alice".to_string(),
        age: 30,
        emails: vec!["alice@example.com".to_string(), "alice.work@example.com".to_string()],
    };

    println!("person instance of Person: {:?}", person);

    // Serialize to bytes
    // Encodes the message to a buffer.
    println!("Encoding person...");
    let encoded = prost::Message::encode_to_vec(&person);
    println!("Encoded bytes: {:?}", encoded);

    // Deserialize from bytes
    // Decodes an instance of the message from a buffer.
    println!("Decoding person...");
    let decoded = Person::decode(&*encoded).unwrap();
    println!("Decoded person: {:?}", decoded);
}
